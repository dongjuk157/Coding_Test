# 동적 계획법(Dynamic Programming)

최적화 문제를 해결하는 알고리즘

큰문제를 작은 문제로 나눠서 푼다.

- 입력 크기가 작은 부분문제들을 모두 해결한 후에 그 해들을 이용하여 보다 큰 크기의 부분 문제들을 해결하여, 최종적으로 원래 주어진 입력의 문제를 해결하는 알고리즘.

- 분할 정복과 다른점은 동적계획법에선 **Memoization**이 사용된다.

Topdown

- 위에서 아래로 내려가는 방식.
- Recursive 함수를 사용하고, 함수 호출을 줄이기 위해 메모이제이션 사용
- 점화식 그대로 호출이 되기 때문에 형식/순서에 얽매이지 않는다.

Bottom-up

- 아래에서 위로 올라가는 방식. 처음값을 구하고 다음값을 계산해 나감
- Iterate(반복적 구조)를 사용해서 시스템 호출스택을 사용하지 않으므로 recursive 구조보다 성능면에서 효율적



##  Memoization

이전에 계산한 값을 메모리에 저장하여 중복되는 함수 호출을 줄이는 방법

전체적인 실행속도를 빠르게 함

**동적 계획법(Dynamic Programming)**의 핵심이 되는 기술

Ex 1. 피보나치 수열

```python
# recursive
memo = [0,1]
def fibo(n):
    global memo
    if n >= 2 and len(memo) <= n:
        memo.append(fibo(n-1) + fibo(n-2))
    return memo[n]
```

```python
# iterate
def fibo(n):
    f = [0, 1]
    for i in range(2, n + 1):
        f.append(f[i-1]+f[i-2])
    return f[n]
```

Ex 2. 이항계수





---

참고 글

[동적계획법](https://coding-all.tistory.com/2)



##### 동적 계획법(DP) 기반의 알고리즘 동작 방식 


1. 구하고자 하는 큰 문제를 작은 부분문제로 나눈다. 

2. 가장 작은 부분 문제(종료 조건, 주로 0 또는 1일때)부터 푼 뒤 값을 저장한다. --> 메모이제이션

3. 메모이제이션된 부분 문제들의 해를 이용하여 차례로 더 큰 상위 문제의 답을 구한다.

4. (3)과정을 가장 큰 문제(구하고자 하는 큰 문제)에 도달할때까지 반복한다.



##### 동적 계획법(DP) 문제 해결 방법(가이드 라인)

1. 몇 차원(=변수 개수) DP를 할 것인가?

2. 변수 개수(=차원)가 정해졌으면 각각의 변수가 무슨 의미인가?

3. DP값이 어떤 의미인가?

4. 어떤 DP값과 다른 DP값의 관계가 있는가? 있으면 어떤 관계인가?

--> 4을 알아내기 위해서 DP 테이블을 직접 채워보시면 가장 확실하게 알 수 있습니다

5. 4의 점화식을 이용하여 재귀 또는 for문 DP로 계산한다.



##### 동적 계획법의 초기화



동적 계획법에서 메모이제이션 말고 또 중요한 것이 초기화인데

이미 계산한 것을 다시 계산하지 않기 위해서는 계산한 것과 계산하지 않은 것의 차이가 있어야 한다.

계산하지 않은 값은 초기값(초기화한 값) 그대로이고 계산한 값은 바뀌어있기 때문에 그것으로 구분한다. 

따라서 동적 계획법에서 계산한 값의 범위를 대략적으로 알아내서 그 범위에 있지 않은 값으로 초기화를 해주어야 한다. 

계산된 값이 0일수 있는 동적계획법의 경우에는 보통 -1(또는 무한대 값이라고 부르는 INT_MAX)을 사용하고 

계산된 값이 0일수 없는 경우에는 그냥 전역변수로 선언한다.